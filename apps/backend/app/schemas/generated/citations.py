# generated by datamodel-codegen:
#   filename:  citations.json
#   timestamp: 2026-02-11T12:57:08+00:00

from __future__ import annotations

from enum import Enum, IntEnum
from typing import Any
from uuid import UUID

from pydantic import AwareDatetime, BaseModel, Field, confloat, conint


class BoundingBox(BaseModel):
    x0: float = Field(..., description='X coordinate of bottom-left corner')
    y0: float = Field(..., description='Y coordinate of bottom-left corner')
    x1: float = Field(..., description='X coordinate of top-right corner')
    y1: float = Field(..., description='Y coordinate of top-right corner')


class CitationSpan(BaseModel):
    page_number: conint(ge=1) = Field(..., description='Page number (1-indexed)')
    bounding_boxes: list[BoundingBox] = Field(
        ...,
        description='Array of bounding boxes for this span (multiple if text wraps across lines)',
    )
    text_content: str = Field(..., description='The text content for this span')


class PageRange(BaseModel):
    start: conint(ge=1) = Field(..., description='Starting page number (1-indexed, inclusive)')
    end: conint(ge=1) = Field(..., description='Ending page number (1-indexed, inclusive)')


class SourceType(Enum):
    effective_coverage = 'effective_coverage'
    effective_exclusion = 'effective_exclusion'
    endorsement = 'endorsement'
    condition = 'condition'
    clause = 'clause'


class ExtractionMethod(Enum):
    docling = 'docling'
    pdfplumber = 'pdfplumber'
    manual = 'manual'


class ResolutionMethod(Enum):
    direct_text_match = 'direct_text_match'
    semantic_chunk_match = 'semantic_chunk_match'
    placeholder = 'placeholder'


class Citation(BaseModel):
    id: UUID = Field(..., description='Unique identifier for this citation')
    document_id: UUID = Field(..., description='ID of the source document')
    source_type: SourceType = Field(..., description='Type of the source being cited')
    source_id: str = Field(..., description='Canonical or stable ID of the source item')
    spans: list[CitationSpan] = Field(
        ..., description='Array of spans representing the citation across one or more pages'
    )
    verbatim_text: str = Field(
        ..., description='The complete verbatim text from the source document'
    )
    primary_page: conint(ge=1) = Field(
        ..., description='Primary page number where the citation appears'
    )
    page_range: PageRange | None = Field(
        None, description='Optional range of pages if citation spans multiple pages'
    )
    extraction_confidence: confloat(ge=0.0, le=1.0) | None = Field(
        None, description='Optional confidence score for the extraction (0-1)'
    )
    extraction_method: ExtractionMethod | None = Field(
        None, description='Optional method used to extract this citation'
    )
    clause_reference: str | None = Field(
        None, description="Optional reference to a specific clause (e.g., '2.3.1')"
    )
    resolution_method: ResolutionMethod | None = Field(
        None,
        description='How the citation was resolved: direct_text_match (exact/fuzzy word match), semantic_chunk_match (embedding-based chunk search), or placeholder (full-page fallback)',
    )


class Rotation(IntEnum):
    integer_0 = 0
    integer_90 = 90
    integer_180 = 180
    integer_270 = 270


class PageDimensions(BaseModel):
    page_number: conint(ge=1) = Field(..., description='Page number (1-indexed)')
    width_points: float = Field(..., description='Width of the page in points')
    height_points: float = Field(..., description='Height of the page in points')
    rotation: Rotation = Field(..., description='Rotation of the page in degrees')


class CitationsResponse(BaseModel):
    citations: list[Citation] = Field(..., description='Array of citations for the document')
    page_dimensions: dict[str, PageDimensions] = Field(
        ..., description='Map of page numbers to their dimensions for coordinate transformation'
    )


class ResponseMeta(BaseModel):
    timestamp: AwareDatetime
    request_id: str
    api_version: str


class ErrorDetail(BaseModel):
    title: str
    status: int
    detail: str
    instance: str | None = None
    request_id: str
    timestamp: AwareDatetime


class ApiResponse(BaseModel):
    status: bool
    message: str
    data: dict[str, Any]
    meta: ResponseMeta
