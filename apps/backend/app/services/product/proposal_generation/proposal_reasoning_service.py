"""Service for generating natural language reasoning for proposal comparisons."""

import json
from typing import List, Dict, Any, Optional
from app.core.unified_llm import UnifiedLLMClient
from app.core.config import settings
from app.schemas.product.policy_comparison import ComparisonChange
from app.utils.logging import get_logger
from app.utils.json_parser import parse_json_safely

LOGGER = get_logger(__name__)

class ProposalReasoningService:
    """Generates broker-facing explanations for renewal changes using LLM."""

    def __init__(self, client: Optional[UnifiedLLMClient] = None):
        if client:
            self.client = client
        else:
            self.client = UnifiedLLMClient(
                provider=settings.llm_provider,
                api_key=settings.gemini_api_key if settings.llm_provider == "gemini" else settings.openrouter_api_key,
                model=settings.gemini_model if settings.llm_provider == "gemini" else settings.openrouter_model,
                base_url=settings.openrouter_api_url if settings.llm_provider == "openrouter" else None,
            )

    async def enrich_changes_with_reasoning(
        self, changes: List[ComparisonChange]
    ) -> List[ComparisonChange]:
        """Enriches each change with a reasoning string generated by LLM."""
        if not changes:
            return []

        # Group by section to minimize LLM calls
        groups = {}
        for change in changes:
            if change.change_type == "no_change":
                continue
            
            section = change.section_type if hasattr(change, "section_type") else change.section
            if section not in groups:
                groups[section] = []
            groups[section].append(change)

        enriched_changes = {id(c): c for c in changes}

        for section_type, section_changes in groups.items():
            try:
                batch_data = [
                    {
                        "id": id(c),
                        "field": c.field_name if hasattr(c, "field_name") else c.field,
                        "old": str(c.old_value),
                        "new": str(c.new_value),
                        "delta": c.delta_type
                    }
                    for c in section_changes
                ]

                prompt = self._get_proposal_reasoning_prompt(section_type, batch_data)
                
                response = await self.client.generate_content(
                    contents=prompt,
                    generation_config={"temperature": 0.2}
                )

                reasoning_results = parse_json_safely(response.text)
                if isinstance(reasoning_results, list):
                    for item in reasoning_results:
                        change_id = item.get("id")
                        reasonText = item.get("reason")
                        if change_id in enriched_changes:
                            enriched_changes[change_id].reasoning = reasonText

            except Exception as e:
                LOGGER.error(f"Failed to generate proposal reasoning for section {section_type}: {e}", exc_info=True)

        return list(enriched_changes.values())

    def _get_proposal_reasoning_prompt(self, section_type: str, batch_data: List[Dict]) -> str:
        return f"""
    You are a senior insurance broker preparing a professional renewal proposal for a client.

    Your task is to review the listed changes for the **"{section_type}"** section and generate
    clear, client-ready reasoning for each item. The explanations should help a broker
    confidently present the renewal by focusing on value, clarity, and risk impact.

    ### Guidance
    - Write **one concise sentence per item** (maximum).
    - Use **plain, professional language** suitable for a client-facing proposal.
    - Clearly highlight **ADVANTAGES** as benefits (e.g., improved protection, broader coverage, better limits).
    - For **GAPS** or **NEGATIVE_CHANGES**, explain them with a balanced, advisory tone
    (e.g., trade-offs, mitigations, or why the change may still be acceptable).
    - Do **not** use sales hype or technical jargon.
    - Do **not** restate raw JSON fieldsâ€”interpret the meaning.

    ### Input (JSON)
    {json.dumps(batch_data, indent=2)}

    ### Output Requirements (STRICT)
    Return **only** a valid JSON array in the following format:
    [
    {{"id": 123, "reason": "One clear, broker-style sentence explaining the change and its impact."}}
    ]

    Each output object must:
    - Use the same `id` as the input item.
    - Contain exactly one key named `reason`.
    - Contain exactly one sentence (no line breaks).

    Do not include any additional text outside the JSON array.
    """